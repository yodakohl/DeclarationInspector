/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(COCO_PARSER_H__)
#define COCO_PARSER_H__

#include "SymbolTable.h"
#include "DataType.h"
#include "wchar.h"
#include <stdio.h>

#include <list>
#include <map>
#include <algorithm> 
#include <string>


#pragma GCC diagnostic ignored "-Wwrite-strings"

/* Coco\R doesn't like <> in Parameter List */
typedef std::list<Declaration*> decllist;
typedef std::list<int> intlist;


#include "Scanner.h"
#include <list>
#include <map>



class Errors {
public:
	int count;			// number of errors detected

	Errors();
	void SynErr(int line, int col, int n);
	void Error(int line, int col, const wchar_t *s);
	void Warning(int line, int col, const wchar_t *s);
	void Warning(const wchar_t *s);
	void Exception(const wchar_t *s);
	void addMessage(int line, const wchar_t *s);
	std::map<int,wchar_t*> mErrorMessages;


}; // Errors

class Parser {
private:
	enum {
		_EOF=0,
		_ident=1,
		_string_literal=2,
		_character_literal=3,
		_floating_literal=4,
		_integer_literal=5,
		_asm_Keyword=52,
		_do_Keyword=53,
		_if_Keyword=54,
		_return_Keyword=55,
		_typedef_Keyword=56,
		_auto_Keyword=57,
		_inline_Keyword=58,
		_typeid_Keyword=59,
		_dynamic_cast_Keyword=60,
		_typename_Keyword=61,
		_else_Keyword=62,
		_sizeof_Keyword=63,
		_break_Keyword=64,
		_case_Keyword=65,
		_mutable_Keyword=66,
		_static_Keyword=67,
		_catch_Keyword=68,
		_explicit_Keyword=69,
		_namespace_Keyword=70,
		_static_cast_Keyword=71,
		_using_Keyword=72,
		_export_Keyword=73,
		_virtual_Keyword=74,
		_extern_Keyword=75,
		_operator_Keyword=76,
		_switch_Keyword=77,
		_template_Keyword=78,
		_volatile_Keyword=79,
		_const_Keyword=80,
		_const_cast_Keyword=81,
		_this_Keyword=82,
		_continue_Keyword=83,
		_for_Keyword=84,
		_throw_Keyword=85,
		_while_Keyword=86,
		_default_Keyword=87,
		_friend_Keyword=88,
		_register_Keyword=89,
		_delete_Keyword=90,
		_goto_Keyword=91,
		_reinterpret_cast_Keyword=92,
		_try_Keyword=93
	};
	int maxT;

	Token *dummyToken;
	int errDist;
	int minErrDist;

	void SynErr(int n);
	void Get();
	void Expect(int n);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);

public:
	Scanner *scanner;
	Errors  *errors;

	Token *t;			// last recognized token
	Token *la;			// lookahead token

SymbolTable *tab;

    wchar_t *globalTemplateName = 0;
    bool globalTemplateNamePointer = false;
    std::wstring fullTemplateName;
    std::wstring fullTemplateDeclaration;



    void Err(const wchar_t* msg) {
        errors->Error(la->line,la->col, msg);
    }

    /* Emit error if type is already defined */
    bool mustNotBeDefined(const wchar_t*name)
    {
        if(tab->isDefined(name))
        {
            Err(L"Datatype already used");
            return false;
        }
        return true;
    }

    /* Emit error if type is not defined */
    bool mustBeDefined(const wchar_t*name)
    {
        if(!tab->isDefined(name))
        {
            Err(L"Datatype not defined");
            return false;
        }
        return true;
    }

    /* Returns true if type is classname
        eg.
        struct node{  // node is predefined
            node *pleft;
        }; 
     */
    bool isPredefined(const wchar_t*name)
    {
        if(!tab->mPreDefine)
            return false;

        if(wcscmp(name,tab->mPreDefine)!=0)
            return false;

        return true;
    }

    /* Add base Class to class */
    void inherit(DataType *classType, wchar_t* baseClass)
    {
        if(!tab->isDefined(baseClass))
        { 
            Err(L"Cannot inherit from undefined object");
            return;
        }
        
        size_t ancestor_size = tab->getSizeOf(baseClass);
        Declaration*ancestor = new Declaration(baseClass,baseClass, ancestor_size,la->line+1,tab->getType(baseClass));
        classType->addMember(ancestor);
    }

    /* Add member to class */
    void addMember( DataType *classType , Declaration *member)
    {
        if(classType != 0 && member != 0)
        {
            classType->addMember(member);
        }
    }

    void addStlElements()
    {
         for(int i = 0; i < 4 ; i++){
                if(globalTemplateNamePointer == true){
                    Declaration *decl = new Declaration(L"element",globalTemplateName,sizeof(void*),la->line+1,tab->getType(globalTemplateName));
                    tab->declareHeap(decl);
                } else {
                    Declaration *decl = new Declaration(L"element",globalTemplateName,tab->getSizeOf(globalTemplateName),la->line+1,tab->getType(globalTemplateName));
                    tab->declareHeap(decl); 
                }
            }
    }


    void addStringElements(wchar_t*string)
    {
         size_t stringlen = std::char_traits<wchar_t>::length (string) -2; //Don't count apostrophes
         for(int i = 0; i < stringlen ; i++){
                    Declaration *decl = new Declaration(L"StringElem",L"char",tab->getSizeOf(L"char"),la->line+1,tab->getType(L"char"));
                    tab->declareHeap(decl); 
         }
    }


    /* Get size of dimension list. Array [3][2] returns 6 */
    int getDimensionSize(intlist *dimensions)
    {
        int arraySize = 1;
        for (auto it : *dimensions)
            arraySize *= it;
        return arraySize;
    }
    
    /*Get Index of Array Element 
      Row-major order

    eg Array [3][2]
    Element 6 for dimension 0 returns 2
    */
    
    int getElementId( intlist *dimensions, int elem,int dimension)
    {    
        //int mod = 1;
        auto it = dimensions->begin();
        for (int i = 0; i < dimension ; i++)
        {
            it++;
        }
        int mod = *it;
        it++;

        int tmpCount = 1;
        for (;it != dimensions->end(); it++)
        {
            tmpCount *= *it;
        }
        return (elem / tmpCount)%mod;
    }


    /* Add Array Elements to declaration details  */
    void addArrayElements(Declaration *decl, intlist *dimensions  )
    {
        
        int dimensionCount = dimensions->size();
        //F? 1/4 r Dimension 1 nichts hinzuf? 1/4 gen
        if(dimensionCount == 0)
            return;

        if(dimensionCount == 1 && (*dimensions->begin()) == 1)
            return;

        decl->setIsArray(true);
        int arraySize = getDimensionSize(dimensions);

        for(int i = 0 ; i < arraySize ; i++)
        {
            wchar_t elementName[255] = L"element [";
            for ( int j = 0 ; j < dimensionCount ; j++)
            {
                wchar_t buf[16];
                coco_swprintf(buf,16, L" %d", getElementId(dimensions,i,j));
                wcscat(elementName, buf);
            }
            wcscat(elementName, L" ]");


            
            Declaration * element;
            if(decl-> mIsPointer == true){
                element = new Declaration(elementName,decl->mType,sizeof(void*),la->line+1,tab->getType(decl->mType));
            } else {
                element = new Declaration(elementName,decl->mType,tab->getSizeOf(decl->mType),la->line+1,tab->getType(decl->mType));
            }
            decl->addDetail(element);
        }
    }

    /* Add padding to Class or Struct and define it at Symbol Table */
    void finishAndDefine( DataType *classType)
    {
        if(classType != 0)
        {
            classType->finish(); tab->define(classType);
        }
    }

    // Check if declaration has type
    bool  equals(wchar_t *A, Declaration  *B)
    {
        if(wcscmp(A,B->mType) == 0)
            return true;
        return false;
    }
    
    // Check if Assignment matches Type
    bool typeMatch(wchar_t *typeA, Declaration *typeB)
    {    
        if (!typeA || !typeB){
            return false;
        }

        if ( wcscmp(typeA ,L"bool") == 0) {
            if (equals(L"bool",typeB) | equals(L"int",typeB))
                return true;
            return false;
        } 
        else if ( wcscmp(typeA ,L"int") == 0) {
            if (equals(L"bool",typeB) | equals(L"int",typeB))
                return true;
            return false;
        }
        else if ( wcscmp(typeA ,L"char") == 0) {
            if (equals(L"char",typeB) | equals(L"int",typeB))
                return true;
            return false;
        }
        else if ( wcscmp(typeA ,L"double") == 0) {
            if (equals(L"double",typeB) | equals(L"float",typeB) | equals(L"int",typeB))
                return true;
            return false;
        }
        else if ( wcscmp(typeA ,L"float") == 0) {
            if (equals(L"double",typeB) | equals(L"float",typeB) | equals(L"int",typeB))
                return true;
            return false;
        }
        else if ( wcscmp(typeA ,L"string") == 0) {
            if (equals(L"string",typeB))
                return true;
            return false;
        }
        else if ( wcscmp(typeA ,L"long") == 0) {
            if (equals(L"double",typeB) | equals(L"int",typeB))
                return true;
            return false;
        }
        else if ( wcscmp(typeA ,L"short") == 0) {
            if (equals(L"long",typeB) | equals(L"int",typeB) | equals(L"short",typeB))
                return true;
            return false;
        }
        else if ( wcscmp(typeA ,L"void") == 0) {
            return false;
        }
        else if ( wcscmp(typeA ,L"long double") == 0) {
            if (equals(L"double",typeB) | equals(L"long double",typeB) | equals(L"int",typeB)| equals(L"float ",typeB)| equals(L"long long",typeB))
                return true;
            return false;
        }
        else {
            if(equals(typeA,typeB))
                return true;
            return false;
        }
        return true;
    }



/*--------------------------------------------------------------------------*/


	Parser(Scanner *scanner);
	~Parser();
	void SemErr(const wchar_t* msg);

	void CSub();
	void simple_declaration(decllist*decl);
	void struct_definition();
	void class_definiton();
	void enum_specifier();
	void union_definition();
	void Ident(wchar_t* &name);
	void literal(Declaration* &decl);
	void new_expression(Declaration* &decl);
	void type_specifier(wchar_t* &name);
	void array_bracket(intlist &dimensions);
	void assignment_operator();
	void declarator(Declaration*&tmpDecl, wchar_t*&type);
	void unary_expression(wchar_t*&type ,bool isPointer);
	void template_specifier();
	void long_type(wchar_t* &name);
	void stl_container(wchar_t* &name);
	void stl_string(wchar_t* &name);
	void enumerator_definition();
	void access_specifier();
	void class_head(DataType *&pStruct);

	void Parse();

}; // end Parser



#endif

